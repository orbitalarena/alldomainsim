<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-37S Spaceplane Simulator - All Domain Sim</title>

    <!-- Cesium -->
    <link rel="stylesheet" href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css">
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }

        #cesiumContainer {
            width: 100%; height: 100%;
            position: absolute; top: 0; left: 0;
        }

        #hudCanvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .panel {
            position: absolute;
            background: rgba(10, 15, 10, 0.85);
            border: 1px solid #00aa00;
            border-radius: 4px;
            padding: 10px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 20;
            pointer-events: auto;
        }

        #flightDataPanel {
            top: 70px; left: 10px; width: 200px;
        }

        #systemsPanel {
            top: 70px; right: 10px; width: 210px;
        }

        #orbitalPanel {
            top: 70px; right: 230px; width: 220px;
            border-color: #0088ff;
            display: none;
        }

        #orbitalPanel h3 {
            color: #44aaff;
            border-bottom-color: #003366;
        }

        #orbitalPanel .data-label { color: #0088cc; }
        #orbitalPanel .data-value { color: #44ccff; }

        #controlsHelp {
            bottom: 10px; left: 50%;
            transform: translateX(-50%);
            max-width: 800px;
            display: none;
        }

        #statusBar {
            top: 5px; left: 50%;
            transform: translateX(-50%);
            padding: 5px 15px;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
        }

        .panel h3 {
            color: #00ff88;
            font-size: 11px;
            margin-bottom: 6px;
            border-bottom: 1px solid #005500;
            padding-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
            line-height: 1.4;
        }

        .data-label { color: #00aa00; }
        .data-value { color: #00ff00; text-align: right; }
        .data-value.warn { color: #ffff00; }
        .data-value.alert { color: #ff3333; }
        .data-value.blue { color: #44ccff; }

        .key-grid {
            display: grid;
            grid-template-columns: 80px 1fr;
            gap: 2px 10px;
        }

        .key { color: #00ffff; font-weight: bold; }
        .key-desc { color: #00aa00; }

        #startOverlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            color: #00ff00;
            font-family: 'Courier New', monospace;
        }

        #startOverlay h1 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #44aaff;
            text-shadow: 0 0 20px rgba(68, 170, 255, 0.5);
        }

        #startOverlay .subtitle {
            font-size: 16px;
            color: #00aa00;
            margin-bottom: 30px;
        }

        .start-btn {
            padding: 12px 30px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            background: rgba(0, 50, 100, 0.5);
            border: 2px solid #44aaff;
            color: #44ccff;
            cursor: pointer;
            margin: 5px;
            border-radius: 4px;
        }

        .start-btn:hover {
            background: rgba(0, 100, 200, 0.3);
        }

        #msgOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #modeIndicator {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #44ccff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 20;
            pointer-events: none;
            display: none;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <canvas id="hudCanvas"></canvas>

    <!-- Status Bar -->
    <div id="statusBar" class="panel">
        X-37S | <span id="simTime">0:00</span> |
        <span id="timeWarpDisplay">1x</span> |
        <span id="pauseStatus">RUNNING</span> |
        <span id="propModeDisplay">---</span> |
        <span id="regimeDisplay" style="font-weight:bold;color:#00ff00">ATMOSPHERIC</span>
    </div>

    <!-- Mode Indicator -->
    <div id="modeIndicator">PLANNER MODE - Press M to return to cockpit</div>

    <!-- Flight Data Panel (Left) -->
    <div id="flightDataPanel" class="panel">
        <h3>Flight Data</h3>
        <div class="data-row"><span class="data-label">IAS</span><span class="data-value" id="fdIAS">0 KT</span></div>
        <div class="data-row"><span class="data-label">TAS</span><span class="data-value" id="fdTAS">0 KT</span></div>
        <div class="data-row"><span class="data-label">Mach</span><span class="data-value" id="fdMach">0.00</span></div>
        <div class="data-row"><span class="data-label">V Inertial</span><span class="data-value" id="fdVInertial">---</span></div>
        <div class="data-row"><span class="data-label">ALT MSL</span><span class="data-value" id="fdAlt">0 FT</span></div>
        <div class="data-row"><span class="data-label">ALT AGL</span><span class="data-value" id="fdAGL">0 FT</span></div>
        <div class="data-row"><span class="data-label">HDG</span><span class="data-value" id="fdHdg">000</span></div>
        <div class="data-row"><span class="data-label">VS</span><span class="data-value" id="fdVS">0 FPM</span></div>
        <div class="data-row"><span class="data-label">G-Load</span><span class="data-value" id="fdG">1.0</span></div>
        <div class="data-row"><span class="data-label">AoA</span><span class="data-value" id="fdAoA">0.0</span></div>
        <div class="data-row"><span class="data-label">Throttle</span><span class="data-value" id="fdThr">0%</span></div>
        <div class="data-row"><span class="data-label">Orb V%</span><span class="data-value" id="fdOrbV">0%</span></div>
        <div class="data-row"><span class="data-label">Dyn Q</span><span class="data-value" id="fdDynQ">---</span></div>
        <div class="data-row"><span class="data-label">Lat</span><span class="data-value" id="fdLat">0.0000</span></div>
        <div class="data-row"><span class="data-label">Lon</span><span class="data-value" id="fdLon">0.0000</span></div>
    </div>

    <!-- Systems Panel (Right) -->
    <div id="systemsPanel" class="panel">
        <h3>Systems</h3>
        <div class="data-row"><span class="data-label">Engine</span><span class="data-value" id="sysEngine">OFF</span></div>
        <div class="data-row"><span class="data-label">Propulsion</span><span class="data-value" id="sysProp">---</span></div>
        <div class="data-row"><span class="data-label">Gear</span><span class="data-value" id="sysGear">DOWN</span></div>
        <div class="data-row"><span class="data-label">Flaps</span><span class="data-value" id="sysFlaps">UP</span></div>
        <div class="data-row"><span class="data-label">Brakes</span><span class="data-value" id="sysBrakes">OFF</span></div>
        <div class="data-row"><span class="data-label">Regime</span><span class="data-value" id="sysRegime">ATMOSPHERIC</span></div>

        <h3 style="margin-top:10px">Autopilot</h3>
        <div class="data-row"><span class="data-label">Status</span><span class="data-value" id="apStatus">OFF</span></div>
        <div class="data-row"><span class="data-label">Mode</span><span class="data-value" id="apMode">---</span></div>
        <div class="data-row"><span class="data-label">Target ALT</span><span class="data-value" id="apAlt">---</span></div>
        <div class="data-row"><span class="data-label">Target HDG</span><span class="data-value" id="apHdg">---</span></div>
        <div class="data-row"><span class="data-label">Target SPD</span><span class="data-value" id="apSpd">---</span></div>

        <h3 style="margin-top:10px">Camera</h3>
        <div class="data-row"><span class="data-label">Mode</span><span class="data-value" id="camMode">CHASE</span></div>
    </div>

    <!-- Orbital Elements Panel (shown when above 80km or in planner mode) -->
    <div id="orbitalPanel" class="panel">
        <h3>Orbital Elements</h3>
        <div class="data-row"><span class="data-label">Apoapsis</span><span class="data-value" id="orbAP">---</span></div>
        <div class="data-row"><span class="data-label">Periapsis</span><span class="data-value" id="orbPE">---</span></div>
        <div class="data-row"><span class="data-label">Incl</span><span class="data-value" id="orbINC">---</span></div>
        <div class="data-row"><span class="data-label">Ecc</span><span class="data-value" id="orbECC">---</span></div>
        <div class="data-row"><span class="data-label">SMA</span><span class="data-value" id="orbSMA">---</span></div>
        <div class="data-row"><span class="data-label">Period</span><span class="data-value" id="orbPeriod">---</span></div>
        <div class="data-row"><span class="data-label">T to AP</span><span class="data-value" id="orbTAP">---</span></div>
        <div class="data-row"><span class="data-label">T to PE</span><span class="data-value" id="orbTPE">---</span></div>
        <h3 style="margin-top:10px">Maneuver Node</h3>
        <div class="data-row"><span class="data-label">dV</span><span class="data-value" id="nodeDV">---</span></div>
        <div class="data-row"><span class="data-label">Burn T</span><span class="data-value" id="nodeBurnT">---</span></div>
        <div class="data-row"><span class="data-label">Post AP</span><span class="data-value" id="nodePostAP">---</span></div>
        <div class="data-row"><span class="data-label">Post PE</span><span class="data-value" id="nodePostPE">---</span></div>
    </div>

    <!-- Controls Help (Bottom, toggled) -->
    <div id="controlsHelp" class="panel">
        <h3>Controls (Press H to hide)</h3>
        <div style="display: flex; gap: 20px; flex-wrap: wrap;">
            <div class="key-grid">
                <span class="key">W / S</span><span class="key-desc">Throttle up/down</span>
                <span class="key">Down / Up</span><span class="key-desc">Pitch up/down</span>
                <span class="key">Left / Right</span><span class="key-desc">Roll left/right</span>
                <span class="key">Ctrl+L/R</span><span class="key-desc">Yaw left/right</span>
                <span class="key">E</span><span class="key-desc">Engine start/stop</span>
                <span class="key">G</span><span class="key-desc">Toggle gear</span>
            </div>
            <div class="key-grid">
                <span class="key">F</span><span class="key-desc">Toggle flaps</span>
                <span class="key">B</span><span class="key-desc">Wheel brakes</span>
                <span class="key">Space</span><span class="key-desc">Pause</span>
                <span class="key">A</span><span class="key-desc">Toggle autopilot</span>
                <span class="key">C</span><span class="key-desc">Cycle camera</span>
                <span class="key">M</span><span class="key-desc">Toggle planner mode</span>
                <span class="key">P</span><span class="key-desc">Cycle propulsion mode</span>
            </div>
            <div class="key-grid">
                <span class="key">+ / -</span><span class="key-desc">Time warp</span>
                <span class="key">H</span><span class="key-desc">Toggle controls help</span>
                <span class="key">R</span><span class="key-desc">Reset aircraft</span>
                <span class="key">N</span><span class="key-desc">Create maneuver node</span>
                <span class="key">Del</span><span class="key-desc">Delete maneuver node</span>
                <span class="key">Enter</span><span class="key-desc">Execute maneuver node</span>
                <span class="key">1 / 2 / 3</span><span class="key-desc">Toggle panels</span>
                <span class="key">O</span><span class="key-desc">Toggle orbital panel</span>
                <span class="key">Tab</span><span class="key-desc">Hide/show all panels</span>
            </div>
            <div class="key-grid">
                <span class="key" style="color:#ff8800">Planner Mode:</span><span class="key-desc"></span>
                <span class="key">W/S</span><span class="key-desc">Prograde/Retrograde</span>
                <span class="key">A/D</span><span class="key-desc">Normal/Anti-normal</span>
                <span class="key">Q/E</span><span class="key-desc">Radial in/out</span>
                <span class="key">Up/Dn</span><span class="key-desc">Adjust node dV</span>
                <span class="key">Lt/Rt</span><span class="key-desc">Move node time</span>
            </div>
        </div>
    </div>

    <!-- Start Overlay -->
    <div id="startOverlay">
        <h1>X-37S SPACEPLANE SIMULATOR</h1>
        <div class="subtitle">All-Domain Simulation Environment - Atmosphere to Orbit</div>
        <div style="margin-bottom: 20px; color: #00aa00;">
            Edwards AFB, California | Runway 22L
        </div>
        <div>
            <button class="start-btn" onclick="startAirborne()">[ 1 ] START AIRBORNE (5000m, 200 m/s)</button>
        </div>
        <div>
            <button class="start-btn" onclick="startRunway()">[ 2 ] START ON RUNWAY</button>
        </div>
        <div>
            <button class="start-btn" onclick="startSuborbital()">[ 3 ] START SUBORBITAL (80km, Mach 10)</button>
        </div>
        <div>
            <button class="start-btn" onclick="startOrbital()">[ 4 ] START IN ORBIT (400km, 7700 m/s)</button>
        </div>
        <div style="margin-top:20px; color: #44ccff; font-size: 14px;">
            Click a button or press <span style="color:#00ffff">1-4</span> to select start mode
        </div>
        <div style="margin-top:10px; color: #008888; font-size: 11px;">
            Press H in-game for controls reference | M for orbital planner
        </div>
    </div>

    <!-- Temporary Message Overlay -->
    <div id="msgOverlay"></div>

    <!-- Early start-screen keyboard handler -->
    <script>
    var _simStarted = false;
    window.addEventListener('keydown', function(e) {
        if (_simStarted) return;
        if (e.code === 'Digit1' || e.code === 'Numpad1') {
            e.preventDefault(); e.stopPropagation();
            if (typeof startAirborne === 'function') startAirborne();
        }
        if (e.code === 'Digit2' || e.code === 'Numpad2') {
            e.preventDefault(); e.stopPropagation();
            if (typeof startRunway === 'function') startRunway();
        }
        if (e.code === 'Digit3' || e.code === 'Numpad3') {
            e.preventDefault(); e.stopPropagation();
            if (typeof startSuborbital === 'function') startSuborbital();
        }
        if (e.code === 'Digit4' || e.code === 'Numpad4') {
            e.preventDefault(); e.stopPropagation();
            if (typeof startOrbital === 'function') startOrbital();
        }
    }, true);
    </script>

    <!-- Scripts: dependencies first, then engine modules, then main -->
    <script src="cesium_config.js"></script>
    <script src="js/fighter_atmosphere.js"></script>
    <script src="js/fighter_sim_engine.js?v=2"></script>
    <script src="js/fighter_hud.js?v=2"></script>
    <script src="js/fighter_autopilot.js"></script>
    <script src="js/spaceplane_orbital.js?v=2"></script>
    <script src="js/spaceplane_hud.js?v=2"></script>
    <script src="js/spaceplane_planner.js"></script>

    <script>
    // =========================================================================
    // SPACEPLANE MAIN APPLICATION
    // =========================================================================
    'use strict';

    const DEG = FighterSimEngine.DEG;
    const RAD = FighterSimEngine.RAD;
    const MPS_TO_KNOTS = 1.94384;
    const M_TO_FT = 3.28084;
    const SPACEPLANE_CONFIG = FighterSimEngine.SPACEPLANE_CONFIG;

    // ---- State ----
    let aircraftState = null;
    let autopilotState = null;
    let isPaused = false;
    let timeWarp = 1;
    let lastTickTime = null;
    let simElapsed = 0;
    let cameraMode = 'chase'; // chase, cockpit, free, planner
    let started = false;
    let plannerMode = false;
    let lastRegime = 'ATMOSPHERIC';

    // Panel visibility state
    let panelVisible = {
        flightData: true,
        systems: true,
        orbital: 'auto',  // 'auto', 'on', 'off'
        help: false,
    };
    let panelsMinimized = false;

    // Keyboard state
    const keys = {};

    // Cesium entities
    let viewer, playerEntity, runwayEntity;
    let playerTrail = [];
    let trailCounter = 0;
    let orbitPolyline = null;
    let predictedOrbitPolyline = null;
    let apMarker = null, peMarker = null;

    // HUD canvas
    let hudCanvas;

    // ---- Cesium Viewer Init ----
    try {
        viewer = new Cesium.Viewer('cesiumContainer', {
            baseLayerPicker: true,
            geocoder: false,
            homeButton: false,
            sceneModePicker: false,
            navigationHelpButton: false,
            animation: false,
            timeline: false,
            fullscreenButton: false,
            vrButton: false,
            infoBox: false,
            selectionIndicator: false,
            shadows: false,
            shouldAnimate: true,
        });

        Cesium.createWorldTerrainAsync().then(function(terrain) {
            viewer.terrainProvider = terrain;
        }).catch(function(e) {
            console.warn('World terrain unavailable:', e);
        });

        addArcGISProviders(viewer);
        viewer.scene.globe.enableLighting = true;
        viewer.scene.screenSpaceCameraController.enableInputs = true;
    } catch(e) {
        console.error('Cesium init error:', e);
        document.getElementById('startOverlay').innerHTML +=
            '<div style="color:#ff3333;margin-top:10px;">Cesium error: ' + e.message + '</div>';
    }

    // HUD canvas setup
    hudCanvas = document.getElementById('hudCanvas');
    hudCanvas.width = hudCanvas.clientWidth;
    hudCanvas.height = hudCanvas.clientHeight;
    FighterHUD.init(hudCanvas);

    window.addEventListener('resize', () => {
        hudCanvas.width = hudCanvas.clientWidth;
        hudCanvas.height = hudCanvas.clientHeight;
        FighterHUD.resize();
        if (typeof SpaceplaneHUD !== 'undefined') SpaceplaneHUD.resize(hudCanvas);
    });

    // ---- Runway Entity ----
    function createRunway() {
        const rwy = FighterSimEngine.EDWARDS;
        const rwyPos = Cesium.Cartesian3.fromRadians(rwy.lon, rwy.lat, rwy.alt);
        const hdgDeg = rwy.heading * RAD;

        runwayEntity = viewer.entities.add({
            position: rwyPos,
            orientation: Cesium.Transforms.headingPitchRollQuaternion(
                rwyPos,
                new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(hdgDeg), 0, 0)
            ),
            box: {
                dimensions: new Cesium.Cartesian3(rwy.width, rwy.length, 0.5),
                material: Cesium.Color.DARKGRAY.withAlpha(0.8),
                outline: true,
                outlineColor: Cesium.Color.WHITE,
            },
        });

        viewer.entities.add({
            position: rwyPos,
            label: {
                text: 'KEDW RWY 22L',
                font: '12px monospace',
                fillColor: Cesium.Color.WHITE,
                outlineColor: Cesium.Color.BLACK,
                outlineWidth: 2,
                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                pixelOffset: new Cesium.Cartesian2(0, -15),
                disableDepthTestDistance: Number.POSITIVE_INFINITY,
            },
        });
    }

    // ---- Player Entity ----
    function createPlayerEntity() {
        const trailColor = Cesium.Color.CYAN.withAlpha(0.6);

        playerEntity = viewer.entities.add({
            name: 'X-37S Spaceplane',
            position: new Cesium.CallbackProperty(() => {
                if (!aircraftState) return Cesium.Cartesian3.fromDegrees(0, 0, 0);
                return Cesium.Cartesian3.fromRadians(
                    aircraftState.lon, aircraftState.lat, aircraftState.alt
                );
            }, false),
            point: {
                pixelSize: 10,
                color: Cesium.Color.fromCssColorString('#44aaff'),
                outlineColor: Cesium.Color.WHITE,
                outlineWidth: 2,
                disableDepthTestDistance: Number.POSITIVE_INFINITY,
            },
        });

        // Trail
        viewer.entities.add({
            name: 'Player Trail',
            polyline: {
                positions: new Cesium.CallbackProperty(() => playerTrail, false),
                width: 2,
                material: trailColor,
            },
        });
    }

    // ---- Orbit Visualization Entities ----
    function createOrbitEntities() {
        // Current orbit polyline (green)
        orbitPolyline = viewer.entities.add({
            name: 'Current Orbit',
            polyline: {
                positions: new Cesium.CallbackProperty(() => {
                    if (typeof SpaceplaneOrbital !== 'undefined' && SpaceplaneOrbital.currentOrbitPositions) {
                        return SpaceplaneOrbital.currentOrbitPositions;
                    }
                    return [];
                }, false),
                width: 2,
                material: Cesium.Color.LIME.withAlpha(0.7),
            },
        });

        // Predicted orbit polyline (blue, shown with maneuver node)
        predictedOrbitPolyline = viewer.entities.add({
            name: 'Predicted Orbit',
            polyline: {
                positions: new Cesium.CallbackProperty(() => {
                    if (typeof SpaceplanePlanner !== 'undefined' && SpaceplanePlanner.predictedOrbitPositions) {
                        return SpaceplanePlanner.predictedOrbitPositions;
                    }
                    return [];
                }, false),
                width: 2,
                material: new Cesium.PolylineDashMaterialProperty({
                    color: Cesium.Color.DODGERBLUE.withAlpha(0.8),
                    dashLength: 16,
                }),
            },
        });

        // Apoapsis marker
        apMarker = viewer.entities.add({
            name: 'Apoapsis',
            position: new Cesium.CallbackProperty(() => {
                if (typeof SpaceplaneOrbital !== 'undefined' && SpaceplaneOrbital.apoapsisPosition) {
                    return SpaceplaneOrbital.apoapsisPosition;
                }
                return Cesium.Cartesian3.fromDegrees(0, 0, 0);
            }, false),
            show: new Cesium.CallbackProperty(() => {
                return typeof SpaceplaneOrbital !== 'undefined' && SpaceplaneOrbital.apoapsisPosition != null;
            }, false),
            point: { pixelSize: 8, color: Cesium.Color.RED },
            label: {
                text: new Cesium.CallbackProperty(() => {
                    if (typeof SpaceplaneOrbital !== 'undefined' && SpaceplaneOrbital.orbitalElements) {
                        const ap = SpaceplaneOrbital.orbitalElements.apoapsisAlt;
                        if (ap != null) return 'AP ' + (ap / 1000).toFixed(0) + ' km';
                    }
                    return 'AP';
                }, false),
                font: '12px monospace',
                fillColor: Cesium.Color.RED,
                outlineColor: Cesium.Color.BLACK,
                outlineWidth: 2,
                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                pixelOffset: new Cesium.Cartesian2(0, -12),
                disableDepthTestDistance: Number.POSITIVE_INFINITY,
            },
        });

        // Periapsis marker
        peMarker = viewer.entities.add({
            name: 'Periapsis',
            position: new Cesium.CallbackProperty(() => {
                if (typeof SpaceplaneOrbital !== 'undefined' && SpaceplaneOrbital.periapsisPosition) {
                    return SpaceplaneOrbital.periapsisPosition;
                }
                return Cesium.Cartesian3.fromDegrees(0, 0, 0);
            }, false),
            show: new Cesium.CallbackProperty(() => {
                return typeof SpaceplaneOrbital !== 'undefined' && SpaceplaneOrbital.periapsisPosition != null;
            }, false),
            point: { pixelSize: 8, color: Cesium.Color.CYAN },
            label: {
                text: new Cesium.CallbackProperty(() => {
                    if (typeof SpaceplaneOrbital !== 'undefined' && SpaceplaneOrbital.orbitalElements) {
                        const pe = SpaceplaneOrbital.orbitalElements.periapsisAlt;
                        if (pe != null) return 'PE ' + (pe / 1000).toFixed(0) + ' km';
                    }
                    return 'PE';
                }, false),
                font: '12px monospace',
                fillColor: Cesium.Color.CYAN,
                outlineColor: Cesium.Color.BLACK,
                outlineWidth: 2,
                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                pixelOffset: new Cesium.Cartesian2(0, -12),
                disableDepthTestDistance: Number.POSITIVE_INFINITY,
            },
        });
    }

    // ---- Camera ----
    let camHeadingOffset = 0;
    let camPitch = -0.3;
    let camRange = 150;
    let camDragging = false;
    let camDragStart = { x: 0, y: 0 };

    // Planner camera state
    let plannerCamRange = 5e7; // 50,000 km initial range for full orbit view

    document.getElementById('cesiumContainer').addEventListener('mousedown', (e) => {
        if (cameraMode === 'free') return;
        if (e.shiftKey || e.button === 2) {
            camDragging = true;
            camDragStart = { x: e.clientX, y: e.clientY };
            e.preventDefault();
        }
    });
    window.addEventListener('mousemove', (e) => {
        if (!camDragging) return;
        const dx = e.clientX - camDragStart.x;
        const dy = e.clientY - camDragStart.y;
        camDragStart = { x: e.clientX, y: e.clientY };
        camHeadingOffset += dx * 0.005;
        camPitch = Math.max(-Math.PI / 2 + 0.05, Math.min(0.3, camPitch - dy * 0.005));
    });
    window.addEventListener('mouseup', () => { camDragging = false; });
    document.getElementById('cesiumContainer').addEventListener('wheel', (e) => {
        if (cameraMode === 'free') return;
        if (plannerMode) {
            plannerCamRange *= (1 + e.deltaY * 0.001);
            plannerCamRange = Math.max(1e5, Math.min(1e8, plannerCamRange));
        } else {
            camRange *= (1 + e.deltaY * 0.001);
            camRange = Math.max(20, Math.min(50000, camRange));
        }
        e.preventDefault();
    }, { passive: false });
    document.getElementById('cesiumContainer').addEventListener('contextmenu', (e) => {
        if (cameraMode !== 'free') e.preventDefault();
    });

    function updateCamera() {
        if (!aircraftState || cameraMode === 'free') return;

        const pos = Cesium.Cartesian3.fromRadians(
            aircraftState.lon, aircraftState.lat, aircraftState.alt
        );

        if (plannerMode) {
            // Planner camera: look at aircraft from far away, top-down view of orbit
            viewer.camera.lookAt(
                pos,
                new Cesium.HeadingPitchRange(
                    aircraftState.heading + camHeadingOffset,
                    -Math.PI / 2.5,
                    plannerCamRange
                )
            );
            return;
        }

        if (cameraMode === 'chase') {
            // Adaptive chase range at high altitude
            const adaptiveRange = aircraftState.alt > 100000 ?
                Math.max(camRange, aircraftState.alt * 0.01) : camRange;

            viewer.camera.lookAt(
                pos,
                new Cesium.HeadingPitchRange(
                    aircraftState.heading + camHeadingOffset,
                    camPitch,
                    adaptiveRange
                )
            );
        } else if (cameraMode === 'cockpit') {
            const enuT = Cesium.Transforms.eastNorthUpToFixedFrame(pos);
            const em = Cesium.Matrix4.getMatrix3(enuT, new Cesium.Matrix3());
            const E = new Cesium.Cartesian3(em[0], em[1], em[2]);
            const N = new Cesium.Cartesian3(em[3], em[4], em[5]);
            const U = new Cesium.Cartesian3(em[6], em[7], em[8]);

            function lc(a, v1, b, v2) {
                const r = new Cesium.Cartesian3();
                Cesium.Cartesian3.add(
                    Cesium.Cartesian3.multiplyByScalar(v1, a, new Cesium.Cartesian3()),
                    Cesium.Cartesian3.multiplyByScalar(v2, b, new Cesium.Cartesian3()),
                    r);
                return r;
            }

            const h = aircraftState.heading + (aircraftState.yawOffset || 0);
            const p = aircraftState.pitch;
            const r = -aircraftState.roll;

            let fwd = lc(Math.sin(h), E, Math.cos(h), N);
            let rgt = lc(Math.cos(h), E, -Math.sin(h), N);
            let up  = Cesium.Cartesian3.clone(U);

            const fwd2 = lc(Math.cos(p), fwd, Math.sin(p), up);
            const up2  = lc(-Math.sin(p), fwd, Math.cos(p), up);
            fwd = fwd2;
            up  = up2;

            const rgt2 = lc(Math.cos(r), rgt, Math.sin(r), up);
            const up3  = lc(-Math.sin(r), rgt, Math.cos(r), up);
            rgt = rgt2;
            up  = up3;

            const camPos = Cesium.Cartesian3.clone(pos);
            Cesium.Cartesian3.add(camPos,
                Cesium.Cartesian3.multiplyByScalar(fwd, 20, new Cesium.Cartesian3()), camPos);
            Cesium.Cartesian3.add(camPos,
                Cesium.Cartesian3.multiplyByScalar(up, 2, new Cesium.Cartesian3()), camPos);

            viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
            viewer.camera.position  = camPos;
            viewer.camera.direction = Cesium.Cartesian3.normalize(fwd, fwd);
            viewer.camera.up        = Cesium.Cartesian3.normalize(up, up);
            viewer.camera.right     = Cesium.Cartesian3.normalize(rgt, rgt);
        }
    }

    function cycleCamera() {
        if (plannerMode) return; // M toggles planner
        const modes = ['chase', 'cockpit', 'free'];
        const idx = modes.indexOf(cameraMode);
        viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
        cameraMode = modes[(idx + 1) % modes.length];
        viewer.scene.screenSpaceCameraController.enableInputs = (cameraMode !== 'cockpit');
        if (playerEntity) {
            playerEntity.show = (cameraMode !== 'cockpit');
        }
        if (cameraMode === 'chase') {
            camHeadingOffset = 0;
            camPitch = -0.3;
            camRange = 150;
        }
        document.getElementById('camMode').textContent = cameraMode.toUpperCase();
        showMessage('Camera: ' + cameraMode.toUpperCase());
    }

    // ---- Planner Mode Toggle ----
    function togglePlannerMode() {
        plannerMode = !plannerMode;

        document.getElementById('modeIndicator').style.display = plannerMode ? 'block' : 'none';

        if (plannerMode) {
            // Switch to planner view
            viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
            viewer.scene.screenSpaceCameraController.enableInputs = true;
            if (playerEntity) playerEntity.show = true;
            // Set planner camera range based on altitude
            plannerCamRange = Math.max(aircraftState.alt * 5, 5e6);
            showMessage('PLANNER MODE');
        } else {
            // Return to cockpit mode
            viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
            cameraMode = 'chase';
            viewer.scene.screenSpaceCameraController.enableInputs = true;
            camHeadingOffset = 0;
            camPitch = -0.3;
            camRange = aircraftState.alt > 100000 ? 5000 : 150;
            document.getElementById('camMode').textContent = 'CHASE';
            showMessage('COCKPIT MODE');
        }
    }

    // ---- Propulsion Mode Toggle ----
    const PROP_MODES_LOCAL = ['AIR', 'HYPERSONIC', 'ROCKET'];
    function cyclePropulsionMode() {
        if (!aircraftState) return;
        const modes = (FighterSimEngine.PROP_MODES) || PROP_MODES_LOCAL;
        const cur = aircraftState.forcedPropMode || 'AIR';
        const idx = modes.indexOf(cur);
        const next = modes[(idx + 1) % modes.length];
        aircraftState.forcedPropMode = next;
        aircraftState.propulsionMode = next; // immediate display update
        // Update status bar and systems panel right away
        setText('propModeDisplay', next);
        const propColor = next === 'ROCKET' ? 'alert' : next === 'HYPERSONIC' ? 'warn' : '';
        setTextWithClass('sysProp', next, propColor);
        showMessage('PROPULSION: ' + next);
    }

    // ---- Keyboard Handling ----
    // Use capture phase + preventDefault/stopPropagation to prevent Cesium
    // from intercepting keys like Enter, Delete, N, M, Space, etc.
    window.addEventListener('keydown', (e) => {
        if (!started) return;

        keys[e.code] = true;

        if (e.repeat) return;

        let handled = true; // assume handled; set false at end if not

        // Panel toggles work in both modes
        if (handlePanelToggle(e.code)) {
            e.preventDefault(); e.stopPropagation();
            return;
        }

        // Planner mode controls
        if (plannerMode) {
            switch (e.code) {
                case 'KeyM':
                    togglePlannerMode();
                    break;

                case 'KeyN':
                    if (typeof SpaceplanePlanner !== 'undefined') {
                        SpaceplanePlanner.createNode(aircraftState, simElapsed);
                        showMessage('MANEUVER NODE CREATED');
                    }
                    break;

                case 'Delete': case 'Backspace':
                    if (typeof SpaceplanePlanner !== 'undefined') {
                        SpaceplanePlanner.deleteSelectedNode();
                        showMessage('NODE DELETED');
                    }
                    break;

                case 'Enter': case 'NumpadEnter':
                    if (typeof SpaceplanePlanner !== 'undefined') {
                        SpaceplanePlanner.executeNode(aircraftState, simElapsed);
                        showMessage('EXECUTING NODE');
                    }
                    break;

                case 'KeyP':
                    cyclePropulsionMode();
                    break;

                case 'Space':
                    isPaused = !isPaused;
                    document.getElementById('pauseStatus').textContent = isPaused ? 'PAUSED' : 'RUNNING';
                    showMessage(isPaused ? 'PAUSED' : 'RESUMED');
                    if (!isPaused) lastTickTime = null;
                    break;

                case 'Equal': case 'NumpadAdd':
                    timeWarp = Math.min(timeWarp * 2, 1024);
                    document.getElementById('timeWarpDisplay').textContent = timeWarp + 'x';
                    showMessage('TIME WARP: ' + timeWarp + 'x');
                    break;

                case 'Minus': case 'NumpadSubtract':
                    timeWarp = Math.max(timeWarp / 2, 0.25);
                    document.getElementById('timeWarpDisplay').textContent = timeWarp + 'x';
                    showMessage('TIME WARP: ' + timeWarp + 'x');
                    break;

                case 'KeyH':
                    togglePanel('help');
                    break;

                default:
                    handled = false;
                    break;
            }
            if (handled) { e.preventDefault(); e.stopPropagation(); }
            return; // Consume other keys in planner mode
        }

        // Normal cockpit mode controls
        switch (e.code) {
            case 'Space':
                isPaused = !isPaused;
                document.getElementById('pauseStatus').textContent = isPaused ? 'PAUSED' : 'RUNNING';
                showMessage(isPaused ? 'PAUSED' : 'RESUMED');
                if (!isPaused) lastTickTime = null;
                break;

            case 'KeyE':
                if (aircraftState) {
                    aircraftState.engineOn = !aircraftState.engineOn;
                    showMessage(aircraftState.engineOn ? 'ENGINE START' : 'ENGINE STOP');
                }
                break;

            case 'KeyG':
                if (aircraftState) {
                    aircraftState.gearDown = !aircraftState.gearDown;
                    aircraftState.gearTransition = SPACEPLANE_CONFIG.gear_transition_time;
                    showMessage(aircraftState.gearDown ? 'GEAR DOWN' : 'GEAR UP');
                }
                break;

            case 'KeyF':
                if (aircraftState) {
                    aircraftState.flapsDown = !aircraftState.flapsDown;
                    showMessage(aircraftState.flapsDown ? 'FLAPS DOWN' : 'FLAPS UP');
                }
                break;

            case 'KeyB':
                if (aircraftState) {
                    aircraftState.brakesOn = !aircraftState.brakesOn;
                    showMessage(aircraftState.brakesOn ? 'BRAKES ON' : 'BRAKES OFF');
                }
                break;

            case 'KeyA':
                if (autopilotState && aircraftState) {
                    FighterAutopilot.toggle(autopilotState, aircraftState);
                    showMessage(autopilotState.enabled ? 'AUTOPILOT ON' : 'AUTOPILOT OFF');
                }
                break;

            case 'KeyP':
                cyclePropulsionMode();
                break;

            case 'KeyM':
                togglePlannerMode();
                break;

            case 'KeyC':
                cycleCamera();
                break;

            case 'KeyH':
                togglePanel('help');
                break;

            case 'Equal': case 'NumpadAdd':
                timeWarp = Math.min(timeWarp * 2, 1024);
                document.getElementById('timeWarpDisplay').textContent = timeWarp + 'x';
                showMessage('TIME WARP: ' + timeWarp + 'x');
                break;

            case 'Minus': case 'NumpadSubtract':
                timeWarp = Math.max(timeWarp / 2, 0.25);
                document.getElementById('timeWarpDisplay').textContent = timeWarp + 'x';
                showMessage('TIME WARP: ' + timeWarp + 'x');
                break;

            case 'KeyR':
                resetAircraft();
                break;

            case 'KeyN':
                if (typeof SpaceplanePlanner !== 'undefined') {
                    SpaceplanePlanner.createNode(aircraftState, simElapsed);
                    showMessage('MANEUVER NODE CREATED');
                }
                break;

            case 'Delete': case 'Backspace':
                if (typeof SpaceplanePlanner !== 'undefined') {
                    SpaceplanePlanner.deleteSelectedNode();
                    showMessage('NODE DELETED');
                }
                break;

            case 'Enter': case 'NumpadEnter':
                if (typeof SpaceplanePlanner !== 'undefined') {
                    SpaceplanePlanner.executeNode(aircraftState, simElapsed);
                    showMessage('EXECUTING NODE');
                }
                break;

            default:
                handled = false;
                break;
        }
        if (handled) { e.preventDefault(); e.stopPropagation(); }
    }, true);

    window.addEventListener('keyup', (e) => {
        keys[e.code] = false;
        e.preventDefault();
        e.stopPropagation();
    }, true);

    /**
     * Build control commands from current key state
     */
    function getControlCommands() {
        const controls = {};

        if (plannerMode) {
            // In planner mode, directional keys control maneuver node adjustments
            if (typeof SpaceplanePlanner !== 'undefined') {
                // W/S = prograde/retrograde thrust
                if (keys['KeyW']) SpaceplanePlanner.adjustNodeDV('prograde', 1);
                if (keys['KeyS']) SpaceplanePlanner.adjustNodeDV('retrograde', 1);
                // A/D = normal/anti-normal
                if (keys['KeyA']) SpaceplanePlanner.adjustNodeDV('normal', 1);
                if (keys['KeyD']) SpaceplanePlanner.adjustNodeDV('antinormal', 1);
                // Q/E = radial in/out
                if (keys['KeyQ']) SpaceplanePlanner.adjustNodeDV('radial_in', 1);
                if (keys['KeyE']) SpaceplanePlanner.adjustNodeDV('radial_out', 1);
                // Arrow keys = adjust node time
                if (keys['ArrowUp']) SpaceplanePlanner.adjustNodeDV('increase', 1);
                if (keys['ArrowDown']) SpaceplanePlanner.adjustNodeDV('decrease', 1);
                if (keys['ArrowLeft']) SpaceplanePlanner.adjustNodeTime(-10);
                if (keys['ArrowRight']) SpaceplanePlanner.adjustNodeTime(10);
            }
            return controls; // No flight controls in planner mode
        }

        // Standard flight controls
        controls.throttleUp = keys['KeyW'];
        controls.throttleDown = keys['KeyS'];

        if (keys['ArrowDown']) controls.pitch = 1;
        else if (keys['ArrowUp']) controls.pitch = -1;
        else controls.pitch = 0;

        if (keys['ArrowLeft'] && !keys['ControlLeft'] && !keys['ControlRight']) controls.roll = -1;
        else if (keys['ArrowRight'] && !keys['ControlLeft'] && !keys['ControlRight']) controls.roll = 1;
        else controls.roll = 0;

        if ((keys['ControlLeft'] || keys['ControlRight']) && keys['ArrowLeft']) controls.yaw = -1;
        else if ((keys['ControlLeft'] || keys['ControlRight']) && keys['ArrowRight']) controls.yaw = 1;
        else controls.yaw = 0;

        return controls;
    }

    // ---- Game Loop ----
    viewer.clock.onTick.addEventListener(function() {
        if (!started || !aircraftState) return;
        if (isPaused) { lastTickTime = null; return; }

        const now = Date.now();
        if (lastTickTime === null) { lastTickTime = now; return; }

        let realDt = (now - lastTickTime) / 1000;
        lastTickTime = now;

        realDt = Math.min(realDt, 0.1);
        const totalDt = realDt * timeWarp;

        simElapsed += totalDt;

        // 1. Get player controls
        let controls = getControlCommands();

        // 2. Autopilot (overrides manual controls if enabled)
        if (autopilotState && autopilotState.enabled && !plannerMode) {
            const apControls = FighterAutopilot.update(autopilotState, aircraftState, totalDt);
            if (apControls.pitch !== undefined) controls.pitch = apControls.pitch;
            if (apControls.roll !== undefined) controls.roll = apControls.roll;
            if (apControls.throttleSet !== undefined) controls.throttleSet = apControls.throttleSet;
        }

        // 3. Step aircraft physics (sub-stepping for stability at high warp)
        const maxSubDt = 0.05;
        const maxSubSteps = 500; // prevent browser freeze
        let remaining = totalDt;
        let steps = 0;
        while (remaining > 0 && steps < maxSubSteps) {
            const subDt = Math.min(remaining, maxSubDt);
            FighterSimEngine.step(aircraftState, controls, subDt, SPACEPLANE_CONFIG);
            remaining -= subDt;
            steps++;
        }

        // 3b. Update player trail
        trailCounter++;
        if (trailCounter % 10 === 0) {
            playerTrail.push(Cesium.Cartesian3.fromRadians(
                aircraftState.lon, aircraftState.lat, aircraftState.alt
            ));
            if (playerTrail.length > 1000) playerTrail.shift();
        }

        // 4. Update orbital state (if module loaded)
        if (typeof SpaceplaneOrbital !== 'undefined') {
            SpaceplaneOrbital.update(aircraftState, simElapsed);
        }

        // 5. Update planner (if module loaded)
        if (typeof SpaceplanePlanner !== 'undefined') {
            SpaceplanePlanner.update(aircraftState, simElapsed);
        }

        // 6. Update camera
        updateCamera();

        // 7. Render HUD
        if (plannerMode) {
            // Render planner HUD
            if (typeof SpaceplaneHUD !== 'undefined') {
                SpaceplaneHUD.render(hudCanvas, aircraftState, simElapsed);
            }
        } else {
            // Render cockpit HUD (with space adaptations)
            FighterHUD.render(aircraftState, autopilotState, null, null, simElapsed);

            // Overlay space HUD elements when above 30km
            if (typeof SpaceplaneHUD !== 'undefined' && aircraftState.alt > 30000) {
                SpaceplaneHUD.renderOverlay(hudCanvas, aircraftState, simElapsed);
            }
        }

        // 8. Update UI panels
        updateFlightDataPanel();
        updateSystemsPanel();
        updateOrbitalPanel();
        updateTimeDisplay();
    });

    // ---- UI Updates ----
    function updateFlightDataPanel() {
        if (!aircraftState) return;

        const isHighAlt = aircraftState.alt > 100000;

        if (isHighAlt) {
            // Space units: m/s or km/s, km altitude
            const speedMs = aircraftState.speed;
            const speedDisplay = speedMs > 1000 ?
                (speedMs / 1000).toFixed(2) + ' km/s' :
                Math.round(speedMs) + ' m/s';
            setText('fdIAS', '---');
            setText('fdTAS', speedDisplay);
            setText('fdMach', aircraftState.mach.toFixed(1));
            setText('fdAlt', (aircraftState.alt / 1000).toFixed(1) + ' km');
            setText('fdAGL', '---');
        } else {
            const ias = Atmosphere.tasToCas(aircraftState.speed, aircraftState.alt) * MPS_TO_KNOTS;
            const tas = aircraftState.speed * MPS_TO_KNOTS;
            const altFt = aircraftState.alt * M_TO_FT;
            const aglFt = (aircraftState.alt - FighterSimEngine.EDWARDS.alt) * M_TO_FT;

            setText('fdIAS', Math.round(ias) + ' KT');
            setText('fdTAS', Math.round(tas) + ' KT');
            setText('fdMach', aircraftState.mach.toFixed(2));
            setText('fdAlt', Math.round(altFt) + ' FT');
            setText('fdAGL', Math.round(aglFt) + ' FT');
        }

        const hdgDeg = aircraftState.heading * RAD;
        const vsFpm = aircraftState.speed * Math.sin(aircraftState.gamma) * 196.85;
        const aoaDeg = aircraftState.alpha * RAD;
        const thrPct = Math.round(aircraftState.throttle * 100);

        setText('fdHdg', Math.round(hdgDeg >= 0 ? hdgDeg : hdgDeg + 360).toString().padStart(3, '0') + '\u00B0');
        setText('fdVS', (vsFpm >= 0 ? '+' : '') + Math.round(vsFpm) + ' FPM');
        setTextWithClass('fdG', aircraftState.g_load.toFixed(1),
                        Math.abs(aircraftState.g_load) > 5 ? 'alert' : Math.abs(aircraftState.g_load) > 3 ? 'warn' : '');
        setText('fdAoA', aoaDeg.toFixed(1) + '\u00B0');
        setText('fdThr', thrPct + '%');

        // Orbital velocity fraction
        const orbVPct = aircraftState.orbitalVfrac ? (aircraftState.orbitalVfrac * 100).toFixed(1) : '0.0';
        setTextWithClass('fdOrbV', orbVPct + '%',
                        aircraftState.orbitalVfrac > 0.95 ? 'blue' : '');

        // Dynamic pressure
        const q = aircraftState.dynamicPressure;
        if (q !== undefined) {
            setText('fdDynQ', q > 1000 ? (q / 1000).toFixed(1) + ' kPa' : q.toFixed(0) + ' Pa');
        }

        // Inertial velocity
        const vInertial = aircraftState.speed;
        if (vInertial > 1000) {
            setText('fdVInertial', (vInertial / 1000).toFixed(2) + ' km/s');
        } else {
            setText('fdVInertial', Math.round(vInertial) + ' m/s');
        }

        setText('fdLat', (aircraftState.lat * RAD).toFixed(4) + '\u00B0');
        setText('fdLon', (aircraftState.lon * RAD).toFixed(4) + '\u00B0');
    }

    function updateSystemsPanel() {
        if (!aircraftState) return;

        setTextWithClass('sysEngine', aircraftState.engineOn ? 'ON' : 'OFF',
                        aircraftState.engineOn ? '' : 'alert');

        // Propulsion mode
        const propMode = aircraftState.propulsionMode || 'AIR';
        const propColor = propMode === 'ROCKET' ? 'alert' : propMode === 'HYPERSONIC' ? 'warn' : '';
        setTextWithClass('sysProp', propMode, propColor);
        setText('propModeDisplay', propMode);

        setText('sysGear', aircraftState.gearDown ? 'DOWN' : 'UP');
        setText('sysFlaps', aircraftState.flapsDown ? 'DOWN' : 'UP');
        setText('sysBrakes', aircraftState.brakesOn ? 'ON' : 'OFF');

        // Flight regime  update systems panel + status bar + flash on change
        if (typeof SpaceplaneOrbital !== 'undefined' && SpaceplaneOrbital.flightRegime) {
            const regime = SpaceplaneOrbital.flightRegime;
            const regimeColor = regime === 'ORBIT' ? 'blue' :
                               regime === 'ESCAPE' ? 'alert' :
                               regime === 'SUBORBITAL' ? 'warn' : '';
            setTextWithClass('sysRegime', regime, regimeColor);

            // Status bar regime display with color
            const regimeEl = document.getElementById('regimeDisplay');
            if (regimeEl) {
                regimeEl.textContent = regime;
                const cssColor = regime === 'ORBIT' ? '#44ccff' :
                                 regime === 'ESCAPE' ? '#ff3333' :
                                 regime === 'SUBORBITAL' ? '#ffff00' : '#00ff00';
                regimeEl.style.color = cssColor;
            }

            // Flash notification on regime change
            if (regime !== lastRegime) {
                showMessage('DOMAIN: ' + regime, 2500);
                lastRegime = regime;
            }
        }

        // Autopilot
        if (autopilotState) {
            setTextWithClass('apStatus', autopilotState.enabled ? 'ON' : 'OFF', '');

            if (autopilotState.enabled) {
                let modes = [];
                if (autopilotState.altHold) modes.push('ALT');
                if (autopilotState.hdgHold) modes.push('HDG');
                if (autopilotState.spdHold) modes.push('SPD');
                setText('apMode', modes.join('+') || '---');
                setText('apAlt', Math.round(autopilotState.targetAlt * M_TO_FT) + ' FT');
                setText('apHdg', Math.round(autopilotState.targetHdg * RAD) + '\u00B0');
                setText('apSpd', Math.round(autopilotState.targetSpeed * MPS_TO_KNOTS) + ' KT');
            } else {
                setText('apMode', '---');
                setText('apAlt', '---');
                setText('apHdg', '---');
                setText('apSpd', '---');
            }
        }
    }

    function updateOrbitalPanel() {
        if (typeof SpaceplaneOrbital === 'undefined') return;

        const elems = SpaceplaneOrbital.orbitalElements;
        const hasValidOrbit = elems && elems.apoapsisAlt != null && elems.apoapsisAlt > 0;

        // Show orbital panel based on toggle override or auto logic
        let show;
        if (panelVisible.orbital === 'on') {
            show = true;
        } else if (panelVisible.orbital === 'off') {
            show = false;
        } else {
            // auto: show when in planner, above 30km, or valid orbit trajectory
            show = aircraftState && (plannerMode || aircraftState.alt > 30000 || hasValidOrbit);
        }
        document.getElementById('orbitalPanel').style.display = show ? 'block' : 'none';
        if (!show) return;

        if (!elems) return;

        // Show "PROJECTED" label when below Karman line
        const orbTitle = document.querySelector('#orbitalPanel h3');
        if (orbTitle) {
            orbTitle.textContent = aircraftState.alt < 80000 ? 'Orbital Elements (PROJECTED)' : 'Orbital Elements';
        }

        setText('orbAP', elems.apoapsisAlt != null ? (elems.apoapsisAlt / 1000).toFixed(1) + ' km' : '---');
        setText('orbPE', elems.periapsisAlt != null ? (elems.periapsisAlt / 1000).toFixed(1) + ' km' : '---');
        setText('orbINC', elems.inclination != null ? (elems.inclination * RAD).toFixed(2) + '\u00B0' : '---');
        setText('orbECC', elems.eccentricity != null ? elems.eccentricity.toFixed(4) : '---');
        setText('orbSMA', elems.sma != null ? (elems.sma / 1000).toFixed(0) + ' km' : '---');

        if (elems.period != null && isFinite(elems.period) && elems.period > 0) {
            const mins = elems.period / 60;
            setText('orbPeriod', mins.toFixed(1) + ' min');
        } else {
            setText('orbPeriod', '---');
        }

        setText('orbTAP', elems.timeToApoapsis != null ? formatTime(elems.timeToApoapsis) : '---');
        setText('orbTPE', elems.timeToPeriapsis != null ? formatTime(elems.timeToPeriapsis) : '---');

        // Maneuver node info
        if (typeof SpaceplanePlanner !== 'undefined' && SpaceplanePlanner.selectedNode) {
            const node = SpaceplanePlanner.selectedNode;
            setText('nodeDV', node.dv.toFixed(1) + ' m/s');
            setText('nodeBurnT', node.burnTime ? node.burnTime.toFixed(0) + 's' : '---');
            setText('nodePostAP', node.postAP != null ? (node.postAP / 1000).toFixed(1) + ' km' : '---');
            setText('nodePostPE', node.postPE != null ? (node.postPE / 1000).toFixed(1) + ' km' : '---');
        } else {
            setText('nodeDV', '---');
            setText('nodeBurnT', '---');
            setText('nodePostAP', '---');
            setText('nodePostPE', '---');
        }
    }

    function formatTime(seconds) {
        if (!isFinite(seconds) || seconds < 0) return '---';
        if (seconds > 86400) return (seconds / 86400).toFixed(1) + 'd';
        if (seconds > 3600) return (seconds / 3600).toFixed(1) + 'h';
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return m + ':' + s.toString().padStart(2, '0');
    }

    function updateTimeDisplay() {
        const mins = Math.floor(simElapsed / 60);
        const secs = Math.floor(simElapsed % 60);
        document.getElementById('simTime').textContent =
            mins + ':' + secs.toString().padStart(2, '0');
    }

    // ---- Helpers ----
    function setText(id, text) {
        const el = document.getElementById(id);
        if (el) el.textContent = text;
    }

    function setTextWithClass(id, text, cls) {
        const el = document.getElementById(id);
        if (el) {
            el.textContent = text;
            el.className = 'data-value' + (cls ? ' ' + cls : '');
        }
    }

    let msgTimeout = null;
    function showMessage(text, duration) {
        const el = document.getElementById('msgOverlay');
        el.textContent = text;
        el.style.opacity = '1';
        if (msgTimeout) clearTimeout(msgTimeout);
        msgTimeout = setTimeout(() => {
            el.style.opacity = '0';
        }, duration || 1500);
    }

    // ---- Panel Toggle System ----
    function applyPanelVisibility() {
        document.getElementById('flightDataPanel').style.display =
            panelVisible.flightData ? 'block' : 'none';
        document.getElementById('systemsPanel').style.display =
            panelVisible.systems ? 'block' : 'none';
        // Orbital panel visibility is handled by updateOrbitalPanel()
        document.getElementById('controlsHelp').style.display =
            panelVisible.help ? 'block' : 'none';
    }

    function togglePanel(name) {
        if (name === 'orbital') {
            // Cycle: auto  on  off  auto
            if (panelVisible.orbital === 'auto') panelVisible.orbital = 'on';
            else if (panelVisible.orbital === 'on') panelVisible.orbital = 'off';
            else panelVisible.orbital = 'auto';
            showMessage('ORBITAL: ' + panelVisible.orbital.toUpperCase());
        } else {
            panelVisible[name] = !panelVisible[name];
            showMessage(name.toUpperCase() + ': ' + (panelVisible[name] ? 'ON' : 'OFF'));
        }
        applyPanelVisibility();
    }

    function toggleAllPanels() {
        panelsMinimized = !panelsMinimized;
        if (panelsMinimized) {
            // Hide all panels  status bar stays
            panelVisible.flightData = false;
            panelVisible.systems = false;
            panelVisible.orbital = 'off';
            panelVisible.help = false;
            showMessage('PANELS HIDDEN (Tab to restore)');
        } else {
            // Restore defaults
            panelVisible.flightData = true;
            panelVisible.systems = true;
            panelVisible.orbital = 'auto';
            panelVisible.help = false;
            showMessage('PANELS RESTORED');
        }
        applyPanelVisibility();
    }

    /**
     * Handle panel toggle keypresses  shared between planner and cockpit mode
     * Returns true if the key was a panel toggle (handled)
     */
    function handlePanelToggle(code) {
        switch (code) {
            case 'Digit1': case 'Numpad1':
                togglePanel('flightData');
                return true;
            case 'Digit2': case 'Numpad2':
                togglePanel('systems');
                return true;
            case 'Digit3': case 'Numpad3':
                togglePanel('orbital');
                return true;
            case 'KeyO':
                togglePanel('orbital');
                return true;
            case 'Tab':
                toggleAllPanels();
                return true;
            default:
                return false;
        }
    }

    // ---- Start Functions ----
    function initSim(options) {
        const airborne = options.airborne !== false;

        aircraftState = FighterSimEngine.createAircraftState({
            airborne: airborne,
            lat: options.lat,
            lon: options.lon,
            alt: options.alt,
            speed: options.speed,
            heading: options.heading,
            throttle: options.throttle,
        });

        aircraftState.infiniteFuel = true;
        aircraftState.propulsionMode = 'AIR';
        aircraftState.forcedPropMode = 'AIR';

        // Override gamma if specified (for orbital insertion)
        if (options.gamma !== undefined) {
            aircraftState.gamma = options.gamma;
            aircraftState.pitch = options.gamma + aircraftState.alpha;
        }

        // Create autopilot
        autopilotState = FighterAutopilot.createAutopilotState();

        // Create Cesium entities
        createRunway();
        createPlayerEntity();
        createOrbitEntities();

        // Position camera
        if (airborne) {
            const pos = Cesium.Cartesian3.fromRadians(
                aircraftState.lon, aircraftState.lat, aircraftState.alt
            );
            const range = aircraftState.alt > 100000 ? 5000 : 200;
            viewer.camera.lookAt(pos,
                new Cesium.HeadingPitchRange(aircraftState.heading, -0.3, range));
            camRange = range;
        } else {
            const rwy = FighterSimEngine.EDWARDS;
            const pos = Cesium.Cartesian3.fromRadians(rwy.lon, rwy.lat, rwy.alt + 50);
            viewer.camera.lookAt(pos,
                new Cesium.HeadingPitchRange(rwy.heading, -0.2, 300));
        }

        document.getElementById('startOverlay').style.display = 'none';
        started = true;
        _simStarted = true;
        lastTickTime = null;
    }

    function resetAircraft() {
        viewer.entities.removeAll();
        playerTrail = [];
        trailCounter = 0;
        orbitPolyline = null;
        predictedOrbitPolyline = null;

        if (typeof SpaceplaneOrbital !== 'undefined') SpaceplaneOrbital.reset();
        if (typeof SpaceplanePlanner !== 'undefined') SpaceplanePlanner.reset();

        plannerMode = false;
        document.getElementById('modeIndicator').style.display = 'none';

        simElapsed = 0;
        lastTickTime = null;
        initSim({ airborne: true });
        showMessage('AIRCRAFT RESET');
    }

    // Exposed start functions
    window.startAirborne = function() {
        initSim({ airborne: true, alt: 5000, speed: 200 });
    };
    window.startRunway = function() {
        initSim({ airborne: false });
    };
    window.startSuborbital = function() {
        // 80km altitude, Mach 10 (~3000 m/s), heading east, climbing
        initSim({
            airborne: true,
            alt: 80000,
            speed: 3000,
            heading: 90 * DEG,
            gamma: 10 * DEG,
            throttle: 1.0,
        });
    };
    window.startOrbital = function() {
        // 400km altitude, ~7700 m/s, heading east, level flight
        initSim({
            airborne: true,
            alt: 400000,
            speed: 7700,
            heading: 90 * DEG,
            gamma: 0,
            throttle: 0,
        });
    };

    </script>
</body>
</html>
