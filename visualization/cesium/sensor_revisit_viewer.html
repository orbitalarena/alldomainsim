<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>LEO Sensor Revisit Visualization</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>
    <script src="cesium_config.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; }
        #cesiumContainer { width: 100%; height: 100%; }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(30, 30, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-family: monospace;
            z-index: 1000;
            min-width: 280px;
        }

        #controls h3 { margin: 0 0 15px 0; color: #00BCD4; }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #444;
        }

        .info-label { color: #888; }
        .info-value { color: #00BCD4; font-weight: bold; }

        #controls button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #2196F3;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
        }

        #controls button:hover { background: #1976D2; }
        #controls button.active { background: #4CAF50; }

        #controls select, #controls input[type="range"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
        }

        #controls label {
            display: block;
            margin: 10px 0 5px 0;
            color: #aaa;
        }

        #colorLegend {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        }

        .legend-bar {
            height: 20px;
            background: linear-gradient(to right, #00ff00, #ffff00, #ff8000, #ff0000, transparent);
            border-radius: 4px;
            margin: 5px 0;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #aaa;
        }

        #statusLog {
            margin-top: 10px;
            padding: 8px;
            background: #222;
            border-radius: 4px;
            font-size: 11px;
            color: #0f0;
            max-height: 80px;
            overflow-y: auto;
        }

        #revisitCanvas { display: none; }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <canvas id="revisitCanvas"></canvas>

    <div id="controls">
        <h3>LEO Sensor Revisit</h3>

        <div class="info-row">
            <span class="info-label">Altitude:</span>
            <span class="info-value" id="altitude">--</span>
        </div>
        <div class="info-row">
            <span class="info-label">Inclination:</span>
            <span class="info-value" id="inclination">--</span>
        </div>
        <div class="info-row">
            <span class="info-label">Sensor FOV:</span>
            <span class="info-value" id="sensorFOV">--</span>
        </div>
        <div class="info-row">
            <span class="info-label">Footprint:</span>
            <span class="info-value" id="footprint">--</span>
        </div>
        <div class="info-row">
            <span class="info-label">Grid Cells:</span>
            <span class="info-value" id="gridCells">--</span>
        </div>
        <div class="info-row">
            <span class="info-label">Time:</span>
            <span class="info-value" id="currentTime">T+0:00</span>
        </div>

        <label>Time Step:</label>
        <input type="range" id="timeSlider" min="0" max="100" value="0">

        <button id="playBtn" onclick="togglePlayback()">Play Animation</button>
        <button id="followBtn" onclick="toggleFollow()">Follow Satellite</button>

        <label>Playback Speed:</label>
        <select id="speedSelect">
            <option value="30">Fast (30ms)</option>
            <option value="60" selected>Normal (60ms)</option>
            <option value="120">Slow (120ms)</option>
        </select>

        <label>Max Age (seconds):</label>
        <input type="range" id="maxAgeSlider" min="10" max="120" value="60">
        <span id="maxAgeValue">60s</span>

        <div id="colorLegend">
            <div style="font-size: 12px; margin-bottom: 5px;">Time Since Seen</div>
            <div class="legend-bar"></div>
            <div class="legend-labels">
                <span>0s</span>
                <span>15s</span>
                <span>30s</span>
                <span>45s</span>
                <span id="legendMax">60s+</span>
            </div>
        </div>

        <div id="statusLog">Loading...</div>
    </div>

    <script>
        function log(msg) {
            const el = document.getElementById('statusLog');
            el.innerHTML = msg + '<br>' + el.innerHTML;
            if (el.children.length > 8) el.removeChild(el.lastChild);
            console.log(msg);
        }

        // Create viewer with base layer picker enabled
        const viewer = new Cesium.Viewer('cesiumContainer', {
            animation: false,
            timeline: false,
            baseLayerPicker: true,
            geocoder: false,
            homeButton: false,
            infoBox: true,
            selectionIndicator: true,
            sceneModePicker: false,
            navigationHelpButton: false
        });

        viewer.scene.globe.enableLighting = false;

        // Data
        let data = null;
        let currentStep = 0;
        let isPlaying = false;
        let playInterval = null;
        let playbackSpeed = 60;
        let maxAge = 60;
        let followSatellite = false;

        // Entities
        let satelliteEntity = null;
        let sensorConeEntity = null;
        let orbitPathEntities = [];

        // Canvas for coverage rendering
        const canvas = document.getElementById('revisitCanvas');
        const ctx = canvas.getContext('2d');
        const CANVAS_WIDTH = 1800;
        const CANVAS_HEIGHT = 900;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // All pre-created imagery layers (one per frame)
        let allImageryLayers = [];
        let currentVisibleLayer = -1;

        // Grid lookup for fast canvas rendering
        let gridLookup = null;

        // Cache state
        let cacheReady = false;

        // Interpolation state
        let lastFrameTime = 0;
        let interpolationEnabled = true;

        // Age to RGB color
        function ageToRGB(age, maxAge) {
            if (age < 0 || age > maxAge) {
                return { r: 0, g: 0, b: 0, a: 0 };
            }

            const t = age / maxAge;
            let r, g, b, a;

            if (t < 0.25) {
                // Bright green to yellow
                const s = t / 0.25;
                r = Math.floor(255 * s);
                g = 255;
                b = 0;
            } else if (t < 0.5) {
                // Yellow to orange
                const s = (t - 0.25) / 0.25;
                r = 255;
                g = Math.floor(255 * (1 - s * 0.5));
                b = 0;
            } else if (t < 0.75) {
                // Orange to red
                const s = (t - 0.5) / 0.25;
                r = 255;
                g = Math.floor(128 * (1 - s));
                b = 0;
            } else {
                // Red fading out
                const s = (t - 0.75) / 0.25;
                r = Math.floor(255 - 55 * s);
                g = 0;
                b = 0;
            }

            // Alpha fades towards maxAge
            a = Math.floor(200 * (1 - t * 0.7));

            return { r, g, b, a };
        }

        // Build grid lookup for fast canvas updates
        function buildGridLookup() {
            log('Building grid lookup...');
            const grid = data.grid;
            const latStep = data.metadata.grid_size_km / 111.0;

            // Create lookup: for each canvas pixel, which grid index?
            gridLookup = new Int32Array(CANVAS_WIDTH * CANVAS_HEIGHT);
            gridLookup.fill(-1);

            for (let i = 0; i < grid.length; i++) {
                const pt = grid[i];

                // Calculate longitude step for this latitude
                let lonStep = latStep / Math.max(0.1, Math.cos(pt.lat * Math.PI / 180));
                lonStep = Math.min(lonStep, 30);

                // Calculate pixel bounds for this grid cell
                const west = pt.lon - lonStep / 2;
                const east = pt.lon + lonStep / 2;
                const south = pt.lat - latStep / 2;
                const north = pt.lat + latStep / 2;

                // Convert to canvas coordinates
                const x1 = Math.floor((west + 180) * CANVAS_WIDTH / 360);
                const x2 = Math.ceil((east + 180) * CANVAS_WIDTH / 360);
                const y1 = Math.floor((90 - north) * CANVAS_HEIGHT / 180);
                const y2 = Math.ceil((90 - south) * CANVAS_HEIGHT / 180);

                // Fill pixels
                for (let y = Math.max(0, y1); y < Math.min(CANVAS_HEIGHT, y2); y++) {
                    for (let x = Math.max(0, x1); x < Math.min(CANVAS_WIDTH, x2); x++) {
                        gridLookup[y * CANVAS_WIDTH + x] = i;
                    }
                }
            }

            log('Grid lookup built');
        }

        // Render coverage to canvas
        function renderCoverageToCanvas(ageValues) {
            const imageData = ctx.createImageData(CANVAS_WIDTH, CANVAS_HEIGHT);
            const pixels = imageData.data;

            for (let i = 0; i < gridLookup.length; i++) {
                const gridIdx = gridLookup[i];
                const pixelIdx = i * 4;

                if (gridIdx >= 0 && gridIdx < ageValues.length) {
                    const age = ageValues[gridIdx];
                    const { r, g, b, a } = ageToRGB(age, maxAge);
                    pixels[pixelIdx] = r;
                    pixels[pixelIdx + 1] = g;
                    pixels[pixelIdx + 2] = b;
                    pixels[pixelIdx + 3] = a;
                } else {
                    // No data - transparent
                    pixels[pixelIdx + 3] = 0;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Pre-create all imagery layers for instant switching
        async function precacheAllFrames() {
            log('Pre-creating imagery layers...');

            // Remove any existing cached layers
            for (const layer of allImageryLayers) {
                if (layer) viewer.imageryLayers.remove(layer);
            }
            allImageryLayers = [];
            currentVisibleLayer = -1;

            const totalFrames = data.frames.length;
            const rectangle = Cesium.Rectangle.fromDegrees(-180, -90, 180, 90);

            for (let i = 0; i < totalFrames; i++) {
                renderCoverageToCanvas(data.frames[i].age);
                const url = canvas.toDataURL('image/png');

                // Use fromUrl for newer Cesium API
                const provider = await Cesium.SingleTileImageryProvider.fromUrl(url, {
                    rectangle: rectangle
                });

                const layer = viewer.imageryLayers.addImageryProvider(provider);
                layer.show = false;  // Hidden by default
                layer.alpha = 1.0;
                allImageryLayers.push(layer);

                // Update progress every 50 frames
                if (i % 50 === 0) {
                    log(`Creating layers: ${Math.round(100 * i / totalFrames)}%`);
                    await new Promise(r => setTimeout(r, 0));
                }
            }

            cacheReady = true;
            log(`Created ${allImageryLayers.length} imagery layers`);
        }

        // Switch visible layer (instant, no flicker)
        function showLayer(frameIndex) {
            if (!cacheReady || frameIndex < 0 || frameIndex >= allImageryLayers.length) return;

            // Hide current layer
            if (currentVisibleLayer >= 0 && currentVisibleLayer < allImageryLayers.length) {
                allImageryLayers[currentVisibleLayer].show = false;
            }

            // Show new layer
            allImageryLayers[frameIndex].show = true;
            currentVisibleLayer = frameIndex;
        }

        // Create satellite and sensor cone
        function createSatelliteEntities() {
            const footprintRadius = data.metadata.footprint_radius_km * 1000;
            const firstFrame = data.frames[0];

            // Initial positions from first frame
            const initialSatPos = Cesium.Cartesian3.fromDegrees(
                firstFrame.sat.lon,
                firstFrame.sat.lat,
                firstFrame.sat.alt
            );
            const initialGroundPos = Cesium.Cartesian3.fromDegrees(
                firstFrame.sat.lon,
                firstFrame.sat.lat,
                0
            );

            // Satellite point
            satelliteEntity = viewer.entities.add({
                name: 'LEO Sensor Satellite',
                position: initialSatPos,
                point: {
                    pixelSize: 14,
                    color: Cesium.Color.CYAN,
                    outlineColor: Cesium.Color.WHITE,
                    outlineWidth: 2,
                    disableDepthTestDistance: Number.POSITIVE_INFINITY
                },
                label: {
                    text: 'SENSOR SAT',
                    font: 'bold 14px sans-serif',
                    fillColor: Cesium.Color.CYAN,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    pixelOffset: new Cesium.Cartesian2(0, -25),
                    disableDepthTestDistance: Number.POSITIVE_INFINITY
                }
            });

            // Sensor footprint circle on ground
            sensorConeEntity = viewer.entities.add({
                name: 'Sensor Footprint',
                position: initialGroundPos,
                ellipse: {
                    semiMajorAxis: footprintRadius,
                    semiMinorAxis: footprintRadius,
                    material: Cesium.Color.CYAN.withAlpha(0.2),
                    outline: true,
                    outlineColor: Cesium.Color.CYAN,
                    outlineWidth: 3,
                    height: 0
                }
            });

            log('Satellite entities created');
        }

        // Build orbit path from all frames, split at longitude discontinuities
        function buildOrbitPath() {
            const frames = data.frames;
            let currentSegment = [];
            const LON_THRESHOLD = 90; // If longitude jumps more than this, start new segment

            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];
                const pos = Cesium.Cartesian3.fromDegrees(
                    frame.sat.lon,
                    frame.sat.lat,
                    frame.sat.alt
                );

                if (currentSegment.length > 0) {
                    const prevFrame = frames[i - 1];
                    const lonDiff = Math.abs(frame.sat.lon - prevFrame.sat.lon);

                    // Check for longitude wrap-around
                    if (lonDiff > LON_THRESHOLD) {
                        // Save current segment and start new one
                        if (currentSegment.length > 1) {
                            const entity = viewer.entities.add({
                                polyline: {
                                    positions: currentSegment,
                                    width: 2,
                                    material: new Cesium.PolylineGlowMaterialProperty({
                                        glowPower: 0.2,
                                        color: Cesium.Color.CYAN.withAlpha(0.5)
                                    })
                                }
                            });
                            orbitPathEntities.push(entity);
                        }
                        currentSegment = [];
                    }
                }

                currentSegment.push(pos);
            }

            // Add final segment
            if (currentSegment.length > 1) {
                const entity = viewer.entities.add({
                    polyline: {
                        positions: currentSegment,
                        width: 2,
                        material: new Cesium.PolylineGlowMaterialProperty({
                            glowPower: 0.2,
                            color: Cesium.Color.CYAN.withAlpha(0.5)
                        })
                    }
                });
                orbitPathEntities.push(entity);
            }

            log(`Orbit path created (${orbitPathEntities.length} segments)`);
        }

        // Interpolate position between two frames
        function interpolatePosition(frame1, frame2, t) {
            // Handle longitude wrap-around
            let lon1 = frame1.sat.lon;
            let lon2 = frame2.sat.lon;
            if (Math.abs(lon2 - lon1) > 180) {
                if (lon1 < lon2) lon1 += 360;
                else lon2 += 360;
            }

            let lon = lon1 + (lon2 - lon1) * t;
            if (lon > 180) lon -= 360;
            if (lon < -180) lon += 360;

            return {
                lon: lon,
                lat: frame1.sat.lat + (frame2.sat.lat - frame1.sat.lat) * t,
                alt: frame1.sat.alt + (frame2.sat.alt - frame1.sat.alt) * t
            };
        }

        // Update satellite position with interpolation
        function updateSatellitePosition(pos) {
            const satPos = Cesium.Cartesian3.fromDegrees(pos.lon, pos.lat, pos.alt);
            satelliteEntity.position = satPos;

            const groundPos = Cesium.Cartesian3.fromDegrees(pos.lon, pos.lat, 0);
            sensorConeEntity.position = groundPos;

            if (followSatellite) {
                viewer.camera.lookAt(
                    satPos,
                    new Cesium.HeadingPitchRange(0, Cesium.Math.toRadians(-45), 2000000)
                );
            }
        }

        // Update time step (called at data rate)
        function updateTimeStep(step) {
            if (!data || step < 0 || step >= data.frames.length) return;

            currentStep = step;
            const frame = data.frames[step];

            // Update satellite position
            updateSatellitePosition(frame.sat);

            // Switch to pre-cached layer (instant)
            showLayer(step);

            // Update UI
            const t = frame.t;
            const mins = Math.floor(t / 60);
            const secs = Math.floor(t % 60);
            document.getElementById('currentTime').textContent =
                `T+${mins}:${secs.toString().padStart(2, '0')}`;
            document.getElementById('timeSlider').value = step;
        }

        // Animation state for smooth interpolation
        let animationStartTime = 0;
        let animationFrameId = null;
        let lastDataStep = 0;

        // Smooth animation loop using requestAnimationFrame
        function animationLoop(timestamp) {
            if (!isPlaying || !data) return;

            // Calculate elapsed time since animation started
            const elapsed = timestamp - animationStartTime;

            // Calculate which data frame we should be showing
            const frameProgress = elapsed / playbackSpeed;
            const targetStep = (lastDataStep + Math.floor(frameProgress)) % data.frames.length;
            const subFrameT = frameProgress - Math.floor(frameProgress);

            // Update data (coverage map) when we cross to a new frame
            if (targetStep !== currentStep) {
                updateTimeStep(targetStep);
                if (targetStep < currentStep) {
                    // Wrapped around - reset animation timing
                    animationStartTime = timestamp;
                    lastDataStep = 0;
                }
            }

            // Interpolate satellite position for smooth movement
            if (interpolationEnabled && data.frames.length > 1) {
                const nextStep = (targetStep + 1) % data.frames.length;
                const frame1 = data.frames[targetStep];
                const frame2 = data.frames[nextStep];

                // Don't interpolate across wrap-around
                if (nextStep > targetStep) {
                    const interpPos = interpolatePosition(frame1, frame2, subFrameT);
                    updateSatellitePosition(interpPos);
                }
            }

            animationFrameId = requestAnimationFrame(animationLoop);
        }

        // Toggle playback
        function togglePlayback() {
            isPlaying = !isPlaying;
            const btn = document.getElementById('playBtn');

            if (isPlaying) {
                btn.textContent = 'Pause';
                btn.classList.add('active');
                animationStartTime = performance.now();
                lastDataStep = currentStep;
                animationFrameId = requestAnimationFrame(animationLoop);
            } else {
                btn.textContent = 'Play Animation';
                btn.classList.remove('active');
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            }
        }

        // Toggle follow
        function toggleFollow() {
            followSatellite = !followSatellite;
            const btn = document.getElementById('followBtn');
            btn.classList.toggle('active', followSatellite);

            if (!followSatellite) {
                viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
            }
        }

        // Load data
        async function loadData() {
            try {
                log('Fetching sensor revisit data...');
                const response = await fetch('sensor_revisit_data.json');
                data = await response.json();

                log(`Loaded: ${data.metadata.num_grid_cells} cells, ${data.metadata.num_time_steps} frames`);

                // Update UI
                document.getElementById('altitude').textContent = data.metadata.altitude_km + ' km';
                document.getElementById('inclination').textContent = data.metadata.inclination_deg + '°';
                document.getElementById('sensorFOV').textContent = (data.metadata.sensor_half_angle_deg * 2) + '°';
                document.getElementById('footprint').textContent = data.metadata.footprint_radius_km.toFixed(0) + ' km';
                document.getElementById('gridCells').textContent = data.metadata.num_grid_cells;
                document.getElementById('timeSlider').max = data.frames.length - 1;

                // Build grid lookup for canvas rendering
                buildGridLookup();

                // Create entities
                createSatelliteEntities();
                buildOrbitPath();

                // Pre-cache all frames for smooth playback
                await precacheAllFrames();

                // Initial view
                updateTimeStep(0);

                // Camera view
                viewer.camera.flyTo({
                    destination: Cesium.Cartesian3.fromDegrees(
                        data.frames[0].sat.lon,
                        data.frames[0].sat.lat - 20,
                        5000000
                    ),
                    orientation: {
                        heading: 0,
                        pitch: Cesium.Math.toRadians(-60),
                        roll: 0
                    }
                });

                log('Visualization ready');
            } catch (error) {
                log('Error: ' + error.message);
                console.error(error);
            }
        }

        // Event listeners
        document.getElementById('timeSlider').addEventListener('input', function() {
            if (isPlaying) togglePlayback();
            updateTimeStep(parseInt(this.value));
        });

        document.getElementById('speedSelect').addEventListener('change', function() {
            playbackSpeed = parseInt(this.value);
            if (isPlaying) {
                togglePlayback();
                togglePlayback();
            }
        });

        document.getElementById('maxAgeSlider').addEventListener('input', async function() {
            const wasPlaying = isPlaying;
            if (wasPlaying) togglePlayback();  // Pause during rebuild

            maxAge = parseInt(this.value);
            document.getElementById('maxAgeValue').textContent = maxAge + 's';
            document.getElementById('legendMax').textContent = maxAge + 's+';

            // Rebuild all layers with new maxAge
            if (data) {
                cacheReady = false;
                await precacheAllFrames();
                updateTimeStep(currentStep);
            }

            if (wasPlaying) togglePlayback();  // Resume
        });

        // Initialize
        loadData();
    </script>
</body>
</html>
