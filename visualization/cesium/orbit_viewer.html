<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Orbit Viewer with Ground Tracks</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>
    <script src="cesium_config.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        html, body, #cesiumContainer {
            width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(42, 42, 42, 0.95);
            padding: 15px;
            border-radius: 5px;
            color: white;
            font-family: sans-serif;
            z-index: 1000;
            min-width: 220px;
        }
        #controls h3 { margin: 0 0 10px 0; font-size: 16px; color: #4CAF50; }
        #controls button {
            padding: 8px 15px;
            margin: 5px 5px 5px 0;
            cursor: pointer;
            background: #2196F3;
            border: none;
            border-radius: 3px;
            color: white;
            font-size: 14px;
        }
        #controls button:hover { background: #1976D2; }
        #controls label { display: block; margin: 10px 0 5px 0; font-size: 13px; }
        #controls input[type="range"] { width: 100%; }
        .checkbox-label { display: flex; align-items: center; margin: 8px 0; cursor: pointer; }
        #controls input[type="checkbox"] { margin-right: 8px; }
        #status { margin-top: 10px; font-size: 12px; color: #aaa; }
        #speedValue { color: #4CAF50; font-weight: bold; }
        #metadataDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(42, 42, 42, 0.95);
            padding: 15px;
            border-radius: 5px;
            color: white;
            font-family: monospace;
            font-size: 13px;
            z-index: 1000;
            min-width: 200px;
        }
        #metadataDisplay h4 { margin: 0 0 10px 0; color: #4CAF50; font-family: sans-serif; }
        .meta-row { margin: 4px 0; }
        .meta-label { color: #aaa; }
        .meta-value { color: #00FF00; }
        #satList {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            font-size: 12px;
        }
        .sat-item {
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        .sat-item:hover { background: rgba(255,255,255,0.1); }
        .sat-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>

    <div id="controls">
        <h3>Orbit Viewer</h3>
        <button onclick="loadOrbitData()">Reload Data</button>
        <button onclick="resetView()">Reset View</button>

        <label>Speed: <span id="speedValue">1x</span></label>
        <input type="range" id="speedSlider" min="0" max="5" value="0" step="1" onchange="updateSpeed(this.value)">

        <label class="checkbox-label">
            <input type="checkbox" id="showOrbits" checked onchange="toggleOrbits()">
            Show Orbit Paths
        </label>

        <label class="checkbox-label">
            <input type="checkbox" id="showGroundTracks" checked onchange="toggleGroundTracks()">
            Show Ground Tracks
        </label>

        <label class="checkbox-label">
            <input type="checkbox" id="showLabels" checked onchange="toggleLabels()">
            Show Labels
        </label>

        <div id="satList"></div>
        <div id="status">Ready...</div>
    </div>

    <div id="metadataDisplay">
        <h4>Simulation Info</h4>
        <div class="meta-row">
            <span class="meta-label">Epoch:</span>
            <span class="meta-value" id="epochValue">--</span>
        </div>
        <div class="meta-row">
            <span class="meta-label">Duration:</span>
            <span class="meta-value" id="durationValue">--</span>
        </div>
        <div class="meta-row">
            <span class="meta-label">Time Step:</span>
            <span class="meta-value" id="timeStepValue">--</span>
        </div>
        <div class="meta-row">
            <span class="meta-label">Sim Time:</span>
            <span class="meta-value" id="simTimeValue">--:--:--</span>
        </div>
    </div>

    <script>
        const speedMultipliers = [1, 10, 60, 600, 3600, 36000];
        const speedLabels = ['1x', '10x', '1min/s', '10min/s', '1hr/s', '10hr/s'];

        // Satellite colors
        const satColors = [
            Cesium.Color.LIME,
            Cesium.Color.CYAN,
            Cesium.Color.YELLOW,
            Cesium.Color.MAGENTA,
            Cesium.Color.ORANGE,
            Cesium.Color.WHITE,
            Cesium.Color.AQUA,
            Cesium.Color.CORAL
        ];

        // Create viewer with animation enabled
        const viewer = new Cesium.Viewer('cesiumContainer', {
            animation: true,
            timeline: true,
            baseLayerPicker: true,
            geocoder: false,
            homeButton: false,
            infoBox: true,
            selectionIndicator: true,
            sceneModePicker: true,
            navigationHelpButton: false        });

        viewer.scene.globe.depthTestAgainstTerrain = false;
        addArcGISProviders(viewer);

        // Storage
        let satelliteEntities = [];
        let orbitEntities = [];
        let groundTrackEntities = [];
        let orbitData = null;
        let startTime = null;

        function resetView() {
            viewer.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(0, 0, 35000000),
                orientation: {
                    heading: 0,
                    pitch: -Cesium.Math.PI_OVER_TWO,
                    roll: 0
                }
            });
        }

        function updateSpeed(value) {
            const multiplier = speedMultipliers[value];
            document.getElementById('speedValue').textContent = speedLabels[value];
            viewer.clock.multiplier = multiplier;
        }

        function toggleOrbits() {
            const show = document.getElementById('showOrbits').checked;
            orbitEntities.forEach(e => { e.show = show; });
        }

        function toggleGroundTracks() {
            const show = document.getElementById('showGroundTracks').checked;
            groundTrackEntities.forEach(e => { e.show = show; });
        }

        function toggleLabels() {
            const show = document.getElementById('showLabels').checked;
            satelliteEntities.forEach(e => { if (e.label) e.label.show = show; });
        }

        function trackSatellite(entity) {
            viewer.trackedEntity = entity;
        }

        function updateSimTime() {
            if (!startTime) return;
            const currentTime = viewer.clock.currentTime;
            const elapsed = Cesium.JulianDate.secondsDifference(currentTime, startTime);
            if (elapsed < 0) return;

            const hours = Math.floor(elapsed / 3600);
            const mins = Math.floor((elapsed % 3600) / 60);
            const secs = Math.floor(elapsed % 60);
            document.getElementById('simTimeValue').textContent =
                `${hours.toString().padStart(2,'0')}:${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
        }

        async function loadOrbitData() {
            const status = document.getElementById('status');
            status.textContent = 'Loading...';

            try {
                // Try loading orbit_data.json from parent directory first
                let response = await fetch('../../orbit_data.json?' + Date.now());
                if (!response.ok) {
                    // Try current directory
                    response = await fetch('orbit_data.json?' + Date.now());
                }
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                orbitData = await response.json();

                // Clear existing entities
                satelliteEntities.forEach(e => viewer.entities.remove(e));
                orbitEntities.forEach(e => viewer.entities.remove(e));
                groundTrackEntities.forEach(e => viewer.entities.remove(e));
                satelliteEntities = [];
                orbitEntities = [];
                groundTrackEntities = [];

                const metadata = orbitData.metadata;
                const duration = metadata.duration || metadata.duration_hours * 3600;

                // Update metadata display
                document.getElementById('epochValue').textContent = metadata.epoch_iso || 'N/A';
                document.getElementById('durationValue').textContent = (duration / 3600).toFixed(1) + ' hrs';
                document.getElementById('timeStepValue').textContent = (metadata.time_step || 60) + ' s';

                // Setup clock
                startTime = Cesium.JulianDate.now();
                const stopTime = Cesium.JulianDate.addSeconds(startTime, duration, new Cesium.JulianDate());

                viewer.clock.startTime = startTime.clone();
                viewer.clock.stopTime = stopTime.clone();
                viewer.clock.currentTime = startTime.clone();
                viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;
                viewer.clock.multiplier = 1;
                viewer.timeline.zoomTo(startTime, stopTime);

                // Build satellite list
                const satList = document.getElementById('satList');
                satList.innerHTML = '<div style="color:#aaa;margin-bottom:5px;font-size:11px;">Click to track:</div>';

                // Create satellites
                orbitData.satellites.forEach((satellite, idx) => {
                    const color = satColors[idx % satColors.length];
                    const colorCss = color.toCssColorString();

                    // Create sampled position property using INERTIAL frame (ECI)
                    const positionProperty = new Cesium.SampledPositionProperty(Cesium.ReferenceFrame.INERTIAL);
                    positionProperty.setInterpolationOptions({
                        interpolationDegree: 3,
                        interpolationAlgorithm: Cesium.LagrangePolynomialApproximation
                    });

                    const groundTrackPositions = [];

                    satellite.positions.forEach(pos => {
                        const time = Cesium.JulianDate.addSeconds(startTime, pos.time, new Cesium.JulianDate());

                        // Handle both new format (eci object) and old format (flat x,y,z)
                        let x, y, z;
                        if (pos.eci) {
                            x = pos.eci.x;
                            y = pos.eci.y;
                            z = pos.eci.z;
                        } else {
                            x = pos.x;
                            y = pos.y;
                            z = pos.z;
                        }

                        const eciPosition = new Cesium.Cartesian3(x, y, z);
                        positionProperty.addSample(time, eciPosition);

                        // Add ground track point if geodetic coordinates available
                        if (pos.geo) {
                            groundTrackPositions.push(Cesium.Cartesian3.fromDegrees(
                                pos.geo.lon,
                                pos.geo.lat,
                                0 // Ground level
                            ));
                        }
                    });

                    // Create satellite entity
                    const satEntity = viewer.entities.add({
                        name: satellite.name,
                        position: positionProperty,
                        point: {
                            pixelSize: 10,
                            color: color,
                            outlineColor: Cesium.Color.WHITE,
                            outlineWidth: 2
                        },
                        path: {
                            leadTime: 0,
                            trailTime: 3600,
                            width: 2,
                            material: new Cesium.ColorMaterialProperty(color.withAlpha(0.6)),
                            resolution: 60
                        },
                        label: {
                            text: satellite.name,
                            font: '14px sans-serif',
                            fillColor: color,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            pixelOffset: new Cesium.Cartesian2(15, 0),
                            showBackground: true,
                            backgroundColor: Cesium.Color.BLACK.withAlpha(0.6),
                            show: document.getElementById('showLabels').checked
                        },
                        description: `
                            <h3>${satellite.name}</h3>
                            <p>ID: ${satellite.id || idx}</p>
                            <p>Data points: ${satellite.positions.length}</p>
                        `
                    });
                    satelliteEntities.push(satEntity);

                    // Create orbit path using full trajectory (in INERTIAL frame)
                    const orbitPositions = satellite.positions.map(pos => {
                        if (pos.eci) {
                            return new Cesium.Cartesian3(pos.eci.x, pos.eci.y, pos.eci.z);
                        }
                        return new Cesium.Cartesian3(pos.x, pos.y, pos.z);
                    });

                    // Need to convert ECI positions to ECEF for static polyline display
                    // Since orbits move relative to Earth, we'll create a time-varying path instead
                    // The path property above handles the orbit visualization

                    // Create ground track polyline
                    if (groundTrackPositions.length > 1) {
                        // Split ground track at antimeridian crossings
                        const segments = [];
                        let currentSegment = [groundTrackPositions[0]];

                        for (let i = 1; i < groundTrackPositions.length; i++) {
                            const pos = satellite.positions[i];
                            const prevPos = satellite.positions[i - 1];

                            // Check for antimeridian crossing (large longitude jump)
                            if (pos.geo && prevPos.geo) {
                                const lonDiff = Math.abs(pos.geo.lon - prevPos.geo.lon);
                                if (lonDiff > 180) {
                                    // Antimeridian crossing - end current segment, start new one
                                    if (currentSegment.length > 1) {
                                        segments.push(currentSegment);
                                    }
                                    currentSegment = [];
                                }
                            }
                            currentSegment.push(groundTrackPositions[i]);
                        }
                        if (currentSegment.length > 1) {
                            segments.push(currentSegment);
                        }

                        // Create polyline for each segment
                        segments.forEach((segment, segIdx) => {
                            const groundTrackEntity = viewer.entities.add({
                                name: satellite.name + ' Ground Track ' + (segIdx + 1),
                                polyline: {
                                    positions: segment,
                                    width: 2,
                                    material: color.withAlpha(0.5),
                                    clampToGround: true
                                },
                                show: document.getElementById('showGroundTracks').checked
                            });
                            groundTrackEntities.push(groundTrackEntity);
                        });
                    }

                    // Add to satellite list
                    const satDiv = document.createElement('div');
                    satDiv.className = 'sat-item';
                    satDiv.innerHTML = `<span class="sat-color" style="background:${colorCss}"></span>${satellite.name}`;
                    satDiv.onclick = () => trackSatellite(satEntity);
                    satList.appendChild(satDiv);
                });

                // Update sim time on clock tick
                viewer.clock.onTick.addEventListener(updateSimTime);

                status.textContent = `Loaded: ${orbitData.satellites.length} satellites`;
                resetView();

            } catch (error) {
                status.textContent = `Error: ${error.message}`;
                console.error(error);
            }
        }

        resetView();
        setTimeout(loadOrbitData, 500);
    </script>
</body>
</html>
